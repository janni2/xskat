#include "ui_x11.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h> // For memset, strlen
#include <X11/Xresource.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include "bitmaps.h"
#include "xdial.h"

// --- External Declarations & Globalish Definitions ---
#ifndef MAX_ITEMS
#define MAX_ITEMS 50
#endif
#define MAX_ITEMS_PER_DIALOG_GUESS MAX_ITEMS
extern OBJECT diloesch[];
extern tx_typ textarr[];
static const int NUM_LANG = 2;

// --- Static data ---
static const int ramp[4][6] = {{0,0,0,0,0,0},{24,0,0,0,0,0},{24,24,0,0,0,0},{24,24,24,0,0,0}};
const unsigned char *fr_gif[4][5] = { {{NULL}} };
const unsigned char *de_gif[4][8] = { {{NULL}} };
const unsigned char *backsd_gif[1] = { {NULL} };
static const int de_flg[4][8] = {{0}}; static const int ggde_flg[4][8] = {{0}}; static const Bool ggcards = False;
static const int cnts[] = {0,0,0,1,1,2,2,3,3,4,1,2,3,4,2,0,1,2,3,4,0};
static const int bigs[] = {32,66,20,30,44,30,20,100,44,100,32,20,32,110,20,50,44,50,0,0};
static const int smls[] = {5,15,57,15,5,125,57,125,5,5,57,5,5,135,57,135};
static const int smlz[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
static const int smlc[] = {1,1,0,0,1,0,0,1,1,1,0,0,1,0,0,1};
static const int frm[2][9][2] = {{{0,4},{1,2},{2,1},{4,0},{0,0},{0,0},{0,0},{0,0},{0,0}},{{0,7},{1,5},{2,3},{3,2},{5,1},{7,0},{0,0},{0,0},{0,0}}};
#define AS_VAL 7 #define ZEHN_VAL 6 #define KOENIG_VAL 5
#define DAME_VAL 4 #define BUBE_VAL 3 #define NEUN_VAL 2
#define ACHT_VAL 1 #define SIEBEN_VAL 0
static unsigned char gif_a[4100], gif_e[4100], gif_c[4100], gif_thegif[250*1024];
static tx_typ temp_message_holder;
static char lang_message_buffers[NUM_LANG][256];

// --- X11 Error Handling ---
static Bool ui_x11_colerr = False;
static int ui_x11_query_err_handler(Display* d, XErrorEvent* e){if(e->error_code==BadAccess)ui_x11_colerr=True;return 0;}

// --- Forward declarations ---
static void ui_x11_init_palette(UI_Context* ctx);
static Bool ui_x11_closest_col(UI_Context* ctx, XColor* xcol);
static unsigned long ui_x11_internal_get_col(UI_Context*,const char*,const char*,const char*,const char*,unsigned long,XColor*);
static void ui_x11_init_card_and_symbol_pixmaps(UI_Context* ctx);
static void ui_x11_create_card_on_pixmap(UI_Context*,Pixmap,int,int,int,Bool);
static void ui_x11_drawimg_on_pixmap(UI_Context*,Pixmap,int,int,int,int,int,Bool);
static int ui_x11_getcode(int*,int,int,const unsigned char*);
static void ui_x11_decompgif(const unsigned char*,unsigned char*,unsigned char**,int*);
static void ui_x11_draw_3d_border(UI_Context*,Window,Pixmap,int,int,int,int,Bool);
static void ui_x11_draw_active_dialog(UI_Context* ctx, int item_idx_to_draw);
static void ui_x11_draw_dialog_focus_indicator(UI_Context* ctx);
static void ui_x11_activate_dialog(UI_Context* ctx, OBJECT* dialog_obj, const char* title_override, const char* message_override, int current_lang_idx);

// --- Dialog Management Helper Functions (static) ---
static tx_typ g_yes_no_title_text; static tx_typ g_yes_no_message_text;
static tx_typ g_yes_no_yes_button_text; static tx_typ g_yes_no_no_button_text;
static char g_yes_no_title_str[NUM_LANG][64]; static char g_yes_no_message_str[NUM_LANG][256];
static char g_yes_no_yes_str[NUM_LANG][10]; static char g_yes_no_no_str[NUM_LANG][10];
static OBJECT g_yes_no_dialog_template[MAX_ITEMS] = {
    {0,0,36,10,4,OB_DAREA|OB_NOMAP|OB_FRAME,0,(char*)1},{2,1,32,1,0,OB_TEXT|OB_CENTERED,0,NULL},
    {2,3,32,4,0,OB_TEXT|OB_CENTERED|OB_MULTILINE,0,NULL},{6,8,10,1,0,OB_EXIT|OB_BUTTON,0,NULL},
    {20,8,10,1,0,OB_EXIT|OB_BUTTON,0,NULL}, {-1,-1,-1,-1,OB_END,-1,NULL,NULL,NULL,NULL,NULL}};
static Bool g_yes_no_template_initialized = False;
static void initialize_yes_no_template_text() { /* ... same as prev turn ... */ if(g_yes_no_template_initialized)return; strcpy(g_yes_no_title_str[0],"Confirmation");strcpy(g_yes_no_title_str[1],"Bestätigung"); strcpy(g_yes_no_message_str[0],"Is this action okay?");strcpy(g_yes_no_message_str[1],"Aktion bestätigen?"); strcpy(g_yes_no_yes_str[0],"Yes");strcpy(g_yes_no_yes_str[1],"Ja"); strcpy(g_yes_no_no_str[0],"No");strcpy(g_yes_no_no_str[1],"Nein"); for(int l=0;l<NUM_LANG;++l)g_yes_no_title_text.t[l]=g_yes_no_title_str[l]; for(int l=0;l<NUM_LANG;++l)g_yes_no_message_text.t[l]=g_yes_no_message_str[l]; for(int l=0;l<NUM_LANG;++l)g_yes_no_yes_button_text.t[l]=g_yes_no_yes_str[l]; for(int l=0;l<NUM_LANG;++l)g_yes_no_no_button_text.t[l]=g_yes_no_no_str[l]; g_yes_no_dialog_template[1].str=&g_yes_no_title_text; g_yes_no_dialog_template[2].str=&g_yes_no_message_text; g_yes_no_dialog_template[3].str=&g_yes_no_yes_button_text; g_yes_no_dialog_template[4].str=&g_yes_no_no_button_text; g_yes_no_template_initialized=True;}
static void ui_x11_prepare_dialog_object(OBJECT* t, const OBJECT* s, int n){for(int i=0;i<n;++i){memcpy(&t[i],&s[i],sizeof(OBJECT));if(s[i].type==OB_END)break;}}
static void ui_x11_draw_3d_border(UI_Context* ctx, Window w, Pixmap p, int x1,int y1,int x2,int y2, Bool rev){/* ... same ... */ unsigned long tl=rev?ctx->x_black_pixel:ctx->x_white_pixel; unsigned long br=rev?ctx->x_white_pixel:ctx->x_black_pixel; GC gc=XCreateGC(ctx->display,w?w:ctx->main_window,0,NULL); XSetForeground(ctx->display,gc,tl); if(w){XDrawLine(ctx->display,w,gc,x1,y1,x2-1,y1);XDrawLine(ctx->display,w,gc,x1,y1,x1,y2-1);} if(p!=None){XDrawLine(ctx->display,p,gc,x1,y1,x2-1,y1);XDrawLine(ctx->display,p,gc,x1,y1,x1,y2-1);} XSetForeground(ctx->display,gc,br); if(w){XDrawLine(ctx->display,w,gc,x1+1,y2,x2,y2);XDrawLine(ctx->display,w,gc,x2,y1+1,x2,y2);} if(p!=None){XDrawLine(ctx->display,p,gc,x1+1,y2,x2,y2);XDrawLine(ctx->display,p,gc,x2,y1+1,x2,y2);} XFreeGC(ctx->display,gc);}
static void ui_x11_activate_dialog(UI_Context* ctx, OBJECT* d_obj, const char* title_ov, const char* msg_ov, int lang_idx){/* ... same, uses lang_idx ... */ if(!ctx||!d_obj)return;ctx->current_active_dialog_object=d_obj;ctx->is_dialog_active=1;ctx->dialog_result_value=UI_DIALOG_RESULT_CANCEL;ctx->dialog_active_button_idx=-1;OBJECT*ob_m=&d_obj[0];int mw=ob_m->w*(isxdigitchar('0')?XTextWidth(ctx->default_font_struct,"0",1):8);int mh=ob_m->h*(ctx->default_font_struct->ascent+ctx->default_font_struct->descent+4);int mx=(ctx->width-mw)/2;int my=(ctx->height-mh)/3;if(mx<0)mx=0;if(my<0)my=0;XSetWindowAttributes swa_d;swa_d.override_redirect=1;swa_d.background_pixel=ctx->x_pixel_background;swa_d.border_pixel=ctx->x_pixel_foreground;swa_d.event_mask=ExposureMask|KeyPressMask;ob_m->win=XCreateWindow(ctx->display,ctx->root_window,mx,my,mw,mh,1,CopyFromParent,InputOutput,CopyFromParent,CWOverrideRedirect|CWBackPixel|CWBorderPixel|CWEventMask,&swa_d);if(title_ov)XStoreName(ctx->display,ob_m->win,title_ov);else if(d_obj[1].type==OB_TEXT&&d_obj[1].str)XStoreName(ctx->display,ob_m->win,d_obj[1].str->t[lang_idx]); if(msg_ov&&ob_m->spec>2&&d_obj[2].str!=OB_NONE){strncpy(lang_message_buffers[lang_idx],msg_ov,sizeof(lang_message_buffers[0])-1);lang_message_buffers[lang_idx][sizeof(lang_message_buffers[0])-1]='\0';for(int k=0;k<NUM_LANG;++k)temp_message_holder.t[k]=lang_message_buffers[k];if(lang_idx!=0&&strcmp(lang_message_buffers[0],lang_message_buffers[lang_idx])!=0){strncpy(lang_message_buffers[0],msg_ov,sizeof(lang_message_buffers[0])-1);}d_obj[2].str=&temp_message_holder;} for(int i=1;d_obj[i].type!=OB_END&&i<MAX_ITEMS;++i){OBJECT*oi=&d_obj[i];if(oi->spec&OB_HIDDEN)continue;int ix=oi->x*(isxdigitchar('0')?XTextWidth(ctx->default_font_struct,"0",1):8);int iy=oi->y*(ctx->default_font_struct->ascent+ctx->default_font_struct->descent+4);int iw=oi->w*(isxdigitchar('0')?XTextWidth(ctx->default_font_struct,"0",1):8);int ih=oi->h*(ctx->default_font_struct->ascent+ctx->default_font_struct->descent+4);if(iw<=0)iw=mw-ix-10;if(ih<=0)ih=(ctx->default_font_struct->ascent+ctx->default_font_struct->descent+4);XSetWindowAttributes swa_i;swa_i.background_pixel=ctx->x_pixel_background;swa_i.border_pixel=ctx->x_pixel_foreground;unsigned long evm_i=ExposureMask|KeyPressMask;if(oi->type==OB_BUTTON||(oi->spec&OB_EXIT))evm_i|=ButtonPressMask|ButtonReleaseMask|EnterWindowMask|LeaveWindowMask;if(oi->type==OB_TEXTEDIT)evm_i|=KeyPressMask;swa_i.event_mask=evm_i;oi->win=XCreateWindow(ctx->display,ob_m->win,ix,iy,iw,ih,0,CopyFromParent,InputOutput,CopyFromParent,CWBackPixel|CWBorderPixel|CWEventMask,&swa_i);XMapWindow(ctx->display,oi->win);if((oi->type==OB_BUTTON||(oi->spec&OB_EXIT))&&ctx->dialog_active_button_idx==-1)ctx->dialog_active_button_idx=i;} XMapWindow(ctx->display,ob_m->win);XRaiseWindow(ctx->display,ob_m->win);}
static void ui_x11_close_active_dialog(UI_Context* ctx) { /* ... same ... */ if(!ctx||!ctx->current_active_dialog_object)return;OBJECT*ob=ctx->current_active_dialog_object;if(ob[0].win!=None){for(int i=1;ob[i].type!=OB_END&&i<MAX_ITEMS;++i){if(ob[i].win!=None){XDestroyWindow(ctx->display,ob[i].win);ob[i].win=None;}}XDestroyWindow(ctx->display,ob[0].win);ob[0].win=None;}ctx->current_active_dialog_object=NULL;ctx->is_dialog_active=0;}
static void ui_x11_draw_dialog_focus_indicator(UI_Context* ctx) { /* ... same ... */ if(!ctx||!ctx->current_active_dialog_object||ctx->dialog_active_button_idx<0)return;OBJECT*oi=&ctx->current_active_dialog_object[ctx->dialog_active_button_idx];if(oi->win==None||!(oi->type==OB_BUTTON||(oi->spec&OB_EXIT)))return;unsigned int w,h,bw,d;Window r;int x,y;XGetGeometry(ctx->display,oi->win,&r,&x,&y,&w,&h,&bw,&d);XSetForeground(ctx->display,ctx->gc,ctx->x_pixel_foreground);XDrawRectangle(ctx->display,oi->win,ctx->gc,1,1,w-3,h-3);}
static void ui_x11_draw_active_dialog(UI_Context* ctx, int item_idx) { /* ... same, uses lang_idx ... */ if(!ctx||!ctx->current_active_dialog_object)return;OBJECT*ob_arr=ctx->current_active_dialog_object;int lang_idx=ctx->current_language_index;if(item_idx==0||item_idx==-1){if(ob_arr[0].win==None)return;XClearWindow(ctx->display,ob_arr[0].win);unsigned int w_m,h_m,db,dd;Window dr;int dx,dy;XGetGeometry(ctx->display,ob_arr[0].win,&dr,&dx,&dy,&w_m,&h_m,&db,&dd);ui_x11_draw_3d_border(ctx,ob_arr[0].win,None,0,0,w_m-1,h_m-1,0);for(int i=1;ob_arr[i].type!=OB_END&&i<MAX_ITEMS;++i)ui_x11_draw_active_dialog(ctx,i);}else{OBJECT*ob_i=&ob_arr[item_idx];if(ob_i->win==None||(ob_i->spec&OB_HIDDEN))return;XClearWindow(ctx->display,ob_i->win);unsigned int w,h,bw,d;Window r;int xg,yg;XGetGeometry(ctx->display,ob_i->win,&r,&xg,&yg,&w,&h,&bw,&d);if(ob_i->type==OB_TEXT||ob_i->type==OB_TEXTEDIT){if(ob_i->str&&ob_i->str->t[lang_idx]){XSetForeground(ctx->display,ctx->gc,ctx->x_pixel_foreground);int tl=strlen(ob_i->str->t[lang_idx]);int tx=(w-XTextWidth(ctx->default_font_struct,ob_i->str->t[lang_idx],tl))/2;int ty=(h+ctx->default_font_struct->ascent-ctx->default_font_struct->descent)/2;if(tx<2)tx=2;if(ty<ctx->default_font_struct->ascent)ty=ctx->default_font_struct->ascent+2;XDrawString(ctx->display,ob_i->win,ctx->gc,tx,ty,ob_i->str->t[lang_idx],tl);}}else if(ob_i->type==OB_BUTTON||(ob_i->spec&OB_EXIT)){ui_x11_draw_3d_border(ctx,ob_i->win,None,0,0,w-1,h-1,(ob_i->spec&OB_SELECTED)?1:0);if(ob_i->str&&ob_i->str->t[lang_idx]){XSetForeground(ctx->display,ctx->gc,ctx->x_pixel_foreground);int tl=strlen(ob_i->str->t[lang_idx]);int tx=(w-XTextWidth(ctx->default_font_struct,ob_i->str->t[lang_idx],tl))/2;int ty=(h+ctx->default_font_struct->ascent-ctx->default_font_struct->descent)/2;XDrawString(ctx->display,ob_i->win,ctx->gc,tx,ty,ob_i->str->t[lang_idx],tl);}}if(ob_i->spec&OB_FRAMED&&!(ob_i->type==OB_BUTTON||(ob_i->spec&OB_EXIT))){XSetForeground(ctx->display,ctx->gc,ctx->x_black_pixel);XDrawRectangle(ctx->display,ob_i->win,ctx->gc,0,0,w-1,h-1);}}if(item_idx==0||item_idx==-1)ui_x11_draw_dialog_focus_indicator(ctx);}
static void ui_x11_dialog_navigate(UI_Context* ctx, int dir) { /* ... same ... */ if(!ctx||!ctx->current_active_dialog_object||ctx->dialog_active_button_idx<0)return;OBJECT*ob=ctx->current_active_dialog_object;int cur=ctx->dialog_active_button_idx;int n_it=0;while(ob[n_it].type!=OB_END&&n_it<MAX_ITEMS)n_it++;ui_x11_draw_active_dialog(ctx,cur);int next=cur;do{next=(next+dir+n_it-1-1)%(n_it-1)+1;}while(!(ob[next].type==OB_BUTTON||(ob[next].spec&OB_EXIT))||(ob[next].spec&OB_DISABLED||ob[next].spec&OB_HIDDEN)); ctx->dialog_active_button_idx=next;ui_x11_draw_dialog_focus_indicator(ctx);}
static int ui_x11_dialog_event_loop(UI_Context* ctx, OBJECT* dialog_obj) { /* ... same, uses button indices 3 and 4 from template for Yes/No ... */ if (!ctx || !dialog_obj) return UI_DIALOG_RESULT_CANCEL; XEvent ev; while(ctx->is_dialog_active){ XNextEvent(ctx->display,&ev); Bool proc=0; Window ev_w=ev.xany.window; int it_idx=-1; if(ev_w==dialog_obj[0].win)it_idx=0; else{for(int i=1;dialog_obj[i].type!=OB_END&&i<MAX_ITEMS;++i){if(ev_w==dialog_obj[i].win){it_idx=i;break;}}} if(it_idx!=-1){proc=1; switch(ev.type){ case Expose: if(ev.xexpose.count==0)ui_x11_draw_active_dialog(ctx,it_idx); break; case ButtonPress: if(it_idx>0&&(dialog_obj[it_idx].type==OB_BUTTON||(dialog_obj[it_idx].spec&OB_EXIT))){ ctx->dialog_active_button_idx=it_idx; ui_x11_draw_active_dialog(ctx,0);  if(dialog_obj[it_idx].spec&OB_EXIT){ if(dialog_obj == g_yes_no_dialog_template) { if(it_idx == 3) ctx->dialog_result_value = UI_DIALOG_RESULT_OK; else if(it_idx == 4) ctx->dialog_result_value = UI_DIALOG_RESULT_CANCEL; else ctx->dialog_result_value = UI_DIALOG_RESULT_OK; } else { ctx->dialog_result_value = (ctx->dialog_active_button_idx % 2 == 0) ? UI_DIALOG_RESULT_OK : UI_DIALOG_RESULT_CANCEL; } ui_x11_close_active_dialog(ctx);}} break; case KeyPress: {KeySym ks=XLookupKeysym(&ev.xkey,0); if(ks==XK_Escape){ctx->dialog_result_value=UI_DIALOG_RESULT_CANCEL;ui_x11_close_active_dialog(ctx);} else if(ks==XK_Return||ks==XK_space){if(ctx->dialog_active_button_idx>0&&(dialog_obj[ctx->dialog_active_button_idx].spec&OB_EXIT)){ if(dialog_obj == g_yes_no_dialog_template) { if(ctx->dialog_active_button_idx == 3) ctx->dialog_result_value = UI_DIALOG_RESULT_OK; else if(ctx->dialog_active_button_idx == 4) ctx->dialog_result_value = UI_DIALOG_RESULT_CANCEL; else ctx->dialog_result_value = UI_DIALOG_RESULT_OK; } else { ctx->dialog_result_value = UI_DIALOG_RESULT_OK; } ui_x11_close_active_dialog(ctx);}} else if(ks==XK_Tab)ui_x11_dialog_navigate(ctx,(ev.xkey.state&ShiftMask)?-1:1);}break; }} else if (ev.xany.window == ctx->main_window && ctx->is_dialog_active) { if (ev.type == Expose && ev.xexpose.count == 0) { ui_x11_draw_active_dialog(ctx, 0); } } } return ctx->dialog_result_value; }

// --- Color and GIF functions (definitions omitted for brevity, same as previous step) ---
static unsigned long ui_x11_internal_get_col(UI_Context* ctx, const char* user_spec, const char* res_cl, const char* res_n, const char* def_col_n, unsigned long def_pix, XColor* out_xc) { /* ... */ char* xdef_color_name = NULL; const char* color_to_parse = user_spec; if (!out_xc) return def_pix; if (!color_to_parse) { if (res_cl && res_n) xdef_color_name = XGetDefault(ctx->display, res_cl, res_n); color_to_parse = xdef_color_name ? xdef_color_name : def_col_n; } if (!color_to_parse) { out_xc->pixel = def_pix; return out_xc->pixel; } if (XParseColor(ctx->display, ctx->colormap, color_to_parse, out_xc) == 0) { fprintf(stderr, "ui_x11: XParseColor failed for '%s'.\n", color_to_parse); if (def_col_n && strcmp(color_to_parse, def_col_n) != 0) { if (XParseColor(ctx->display, ctx->colormap, def_col_n, out_xc) == 0) { fprintf(stderr, "ui_x11: XParseColor also failed for default '%s'. Using hardcoded pixel.\n", def_col_n); out_xc->pixel = def_pix; return out_xc->pixel; } color_to_parse = def_col_n; } else { out_xc->pixel = def_pix; return out_xc->pixel; } } if (XAllocColor(ctx->display, ctx->colormap, out_xc) == 0) { fprintf(stderr, "ui_x11: XAllocColor failed for '%s'. Trying closest match.\n", color_to_parse); if (!ui_x11_closest_col(ctx, out_xc)) {  fprintf(stderr, "ui_x11: closest_col also failed for '%s'. Using hardcoded pixel.\n", color_to_parse); out_xc->pixel = def_pix; XColor qf; qf.pixel = def_pix; if(XQueryColor(ctx->display, ctx->colormap, &qf)){ *out_xc = qf; } else { if (def_pix == ctx->x_black_pixel) { out_xc->red=0;out_xc->green=0;out_xc->blue=0;} else { out_xc->red=0xFFFF;out_xc->green=0xFFFF;out_xc->blue=0xFFFF;}} } } if (ctx->x_color_cache_count < 256) ctx->x_color_cache[ctx->x_color_cache_count++] = *out_xc; else fprintf(stderr, "ui_x11: XColor cache is full. Not caching '%s'.\n", color_to_parse); return out_xc->pixel; }
unsigned long ui_x11_get_pixel(UI_Context* ctx, UI_Color color) { /* ... */ if (!ctx) return 0; char hex[8]; sprintf(hex, "#%02x%02x%02x", color.r,color.g,color.b); XColor xc; return ui_x11_internal_get_col(ctx, hex, ctx->program_name, "customWebColor", NULL, ctx->x_black_pixel, &xc); }
static Bool ui_x11_closest_col(UI_Context* ctx, XColor* xcol) { /* ... */ int i,k=0;long dr,dg,db,d_sq=-1,m;int (*oh)(Display*,XErrorEvent*); oh=XSetErrorHandler(ui_x11_query_err_handler);ui_x11_colerr=0; if(!ctx->x_system_colormap_cached){int nq=256;for(i=0;i<nq;++i)ctx->x_system_colormap_cache[i].pixel=i; if(XQueryColors(ctx->display,ctx->colormap,ctx->x_system_colormap_cache,nq)==0 && XQueryColors(ctx->display,DefaultColormap(ctx->display,ctx->screen),ctx->x_system_colormap_cache,nq)==0){XSetErrorHandler(oh);fprintf(stderr,"ui_x11_closest_col: Failed to query colors.\n");return 0;}ctx->x_system_colormap_cached=1;}XSetErrorHandler(oh);if(ui_x11_colerr){fprintf(stderr,"ui_x11_closest_col: Error during XQueryColors.\n");return 0;}for(i=0;i<256;i++){if(!(ctx->x_system_colormap_cache[i].flags&(1|2|4)))continue;dr=(long)ctx->x_system_colormap_cache[i].red-xcol->red;dg=(long)ctx->x_system_colormap_cache[i].green-xcol->green;db=(long)ctx->x_system_colormap_cache[i].blue-xcol->blue;m=dr*dr+dg*dg+db*db;if(d_sq<0||m<d_sq){d_sq=m;k=i;}}if(d_sq==-1){fprintf(stderr,"ui_x11_closest_col: No valid colors in system cache.\n");return 0;}xcol->red=ctx->x_system_colormap_cache[k].red;xcol->green=ctx->x_system_colormap_cache[k].green;xcol->blue=ctx->x_system_colormap_cache[k].blue;xcol->flags=DoRed|DoGreen|DoBlue;return XAllocColor(ctx->display,ctx->colormap,xcol);}
static int ui_x11_getcode(int *bpos, int csiz, int msk, const unsigned char* d){ /* ... */ int i,k=0; for(i=0;i<csiz;i++){ if((*bpos/8)>=250*1024)return 0x102; k|=((d[*bpos/8]>>(*bpos%8))&1)<<i; (*bpos)++; } return k&msk; }
static void ui_x11_decompgif(const unsigned char *td, unsigned char* tp, unsigned char** tm, int*cs){ /* ... */ int i=0,b,bp,mc,sz,co,op,cp,es; int cz,mk; *cs=td[i++]*3; *tm=(unsigned char*)&(td[i]); i+=*cs; b=td[i++]; memcpy(gif_thegif,&(td[i]),250*1024-i); bp=0; mc=1<<b; op=0; es=mc+1; cp=mc+2; cz=b+1; mk=(1<<cz)-1; while((co=ui_x11_getcode(&bp,cz,mk,gif_thegif))!=es){ if(co==mc){cz=b+1;mk=(1<<cz)-1;cp=mc+2;co=ui_x11_getcode(&bp,cz,mk,gif_thegif);} if(co>=cp&&co!=0x102)return; if(co==0x102)return; if(op)gif_e[cp]=co; else gif_e[cp]=-1; gif_c[cp]=(op?gif_a[op]:co); cp++; if((cp&mk)==0&&cp<4096){cz++;mk=(1<<cz)-1;} sz=0; while(co>=mc){gif_a[sz++]=gif_c[co];co=gif_e[co];if(sz>4098)return;} gif_a[sz++]=co; if(op)gif_a[op]=co; op=cp-1; for(i=sz-1;i>=0;i--){if(tp)*(tp++)=gif_a[i];}} }
static void ui_x11_drawimg_on_pixmap(UI_Context* ctx, Pixmap pmap, int cidx, int f, int w, int xo, int yo, Bool large){ /* ... */ int i,k,x,y,dx,dy,sx,sy,wx,wy; unsigned char *map=NULL,*pic=NULL; int cs=0; const unsigned char *gd=NULL; XPoint *pts=NULL; int npts=0,mpts=0; unsigned long lpix=-1; if(cidx<0){if(backsd_gif[0])gd=backsd_gif[0];} else if(ctx->card_style>=2){if(f<4&&w<8&&de_gif[f][w])gd=de_gif[f][w];} else{if(f<4&&w<5&&fr_gif[f][w])gd=fr_gif[f][w];} if(!gd){return;} pic=(unsigned char*)malloc(6000); if(!pic)return; ui_x11_decompgif(gd,pic,&map,&cs); dx=(large?96:64);dy=(large?141:94); sx=pic[0];sy=pic[1]; if(sx==0||sy==0){free(pic);return;} mpts=sx*sy; pts=(XPoint*)malloc(mpts*sizeof(XPoint)); if(!pts){free(pic);return;} for(y=0;y<sy;y++){for(x=0;x<sx;x++){ k=pic[2+x+y*sx]; if(k>=cs/3)k=0; unsigned long cp; if(ctx->x_display_planes>1){ if(k<ctx->x_color_cache_count)cp=ctx->x_color_cache[k].pixel; else{UI_Color fc={(unsigned char)map[k*3],(unsigned char)map[k*3+1],(unsigned char)map[k*3+2],255}; cp=ui_x11_get_pixel(ctx,fc);}} else{cp=(k?ctx->x_black_pixel:ctx->x_white_pixel);} if(npts==0){lpix=cp;XSetForeground(ctx->display,ctx->gc,lpix);} else if(cp!=lpix){ XDrawPoints(ctx->display,pmap,ctx->gc,pts,npts,CoordModeOrigin);npts=0;lpix=cp;XSetForeground(ctx->display,ctx->gc,lpix);} wx=xo+(x*dx/sx);wy=yo+(y*dy/sy); pts[npts].x=wx;pts[npts].y=wy;npts++; if(npts>=mpts){XDrawPoints(ctx->display,pmap,ctx->gc,pts,npts,CoordModeOrigin);npts=0;} }} if(npts>0)XDrawPoints(ctx->display,pmap,ctx->gc,pts,npts,CoordModeOrigin); free(pts);free(pic); }
static void ui_x11_init_palette(UI_Context* ctx){ /* ... */ XColor t[32];int tc=0;Bool fo[6][6][6];int r,g,b;memset(fo,0,sizeof(fo));for(int ri=0;ri<4;++ri)ui_x11_find_cardcol(NULL,0,0,ramp[ri],fo,&r,&g,&b);for(int i=0;i<4;i++){for(int ko=0;ko<2;ko++){int k=ko*3;if(ramp[i][k]<0)continue;XColor x;x.red=(unsigned short)((ramp[i][k]*65535)/24);x.green=(unsigned short)((ramp[i][k+1]*65535)/24);x.blue=(unsigned short)((ramp[i][k+2]*65535)/24);x.flags=DoRed|DoGreen|DoBlue;if(fo[ramp[i][k]/4][ramp[i][k+1]/4][ramp[i][k+2]/4]){if(XAllocColor(ctx->display,ctx->colormap,&x)||ui_x11_closest_col(ctx,&x)){if(tc<32)t[tc++]=x;}}}}for(int i=0;i<tc;++i){Bool aic=0;for(int j=0;j<ctx->x_color_cache_count;++j){if(ctx->x_color_cache[j].pixel==t[i].pixel){aic=1;break;}}if(!aic&&ctx->x_color_cache_count<256)ctx->x_color_cache[ctx->x_color_cache_count++]=t[i];}}
static int ui_x11_closecol(int r, int g, int b, int n, const XColor fixed[256], const Bool found[6][6][6]) { /* ... */ int i, k=0; long dr,dg,db,d=-1,m; for(i=0;i<n;i++){ if(found&&!found[((fixed[i].red*24)/65535)/4][((fixed[i].green*24)/65535)/4][((fixed[i].blue*24)/65535)/4])continue; dr=(long)fixed[i].red-r;dg=(long)fixed[i].green-g;db=(long)fixed[i].blue-b;m=dr*dr+dg*dg+db*db;if(d<0||m<d){d=m;k=i;}} return k; }
static void ui_x11_find_cardcol(const unsigned char* bd[], int gis, int gie, const int rs[6], Bool cfm[6][6][6], int* r, int* g, int* b) { /* ... */ for(int i=0;i<2;++i){int rv=rs[i*3+0];int gv=rs[i*3+1];int bv=rs[i*3+2];if(rv>=0&&gv>=0&&bv>=0&&rv<=24&&gv<=24&&bv<=24){cfm[rv/4][gv/4][bv/4]=1;}} if(r)*r=rs[0]*255/24;if(g)*g=rs[1]*255/24;if(b)*b=rs[2]*255/24;}
static void ui_x11_init_card_and_symbol_pixmaps(UI_Context* ctx) { /* ... */ if(!ctx||!ctx->display||!ctx->main_window)return;
    #ifndef symbs_width
    #define symbs_width 128 #define symbs_height 64 const unsigned char symbs_bits[]={0}; #endif
    #ifndef symbl_width
    #define symbl_width 192 #define symbl_height 96 const unsigned char symbl_bits[]={0}; #endif
    ctx->symbols_pixmap=XCreateBitmapFromData(ctx->display,ctx->main_window,(char*)symbs_bits,symbs_width,symbs_height); if(ctx->symbols_pixmap==None)fprintf(stderr,"ui_x11: Failed to create symbols_pixmap.\n");
    if(ctx->use_large_cards){ctx->large_symbols_pixmap=XCreateBitmapFromData(ctx->display,ctx->main_window,(char*)symbl_bits,symbl_width,symbl_height); if(ctx->large_symbols_pixmap==None)fprintf(stderr,"ui_x11: Failed to create large_symbols_pixmap.\n");}else{ctx->large_symbols_pixmap=ctx->symbols_pixmap;}
    for(int i=0;i<33;++i){int cidx=i-1;int cw=ctx->use_large_cards?ctx->card_width_large:ctx->card_width_small;int ch=ctx->use_large_cards?ctx->card_height_large:ctx->card_height_small; ctx->card_pixmaps[i]=XCreatePixmap(ctx->display,ctx->main_window,cw,ch,DefaultDepth(ctx->display,ctx->screen)); if(ctx->card_pixmaps[i]==None){fprintf(stderr,"ui_x11: Failed to create pixmap for card_pixmaps[%d].\n",i);return;} ui_x11_create_card_on_pixmap(ctx,ctx->card_pixmaps[i],cidx,cw,ch,ctx->use_large_cards);}}
static void ui_x11_create_card_on_pixmap(UI_Context* ctx, Pixmap target_pixmap, int card_index_c, int current_card_width, int current_card_height, Bool is_large_desk) { /* ... */ XSetForeground(ctx->display, ctx->gc_background, ctx->x_white_pixel); XFillRectangle(ctx->display, target_pixmap, ctx->gc_background, 0, 0, current_card_width, current_card_height); int x_offset=2, y_offset=0; int eff_ww = is_large_desk?89:59; int eff_hh = is_large_desk?139:93; if(card_index_c < 0){ if(backsd_gif[0])ui_x11_drawimg_on_pixmap(ctx,target_pixmap,card_index_c,0,0,x_offset,y_offset,is_large_desk); else{UI_Color cbg={0,0,128,255}; XSetForeground(ctx->display,ctx->gc_background,ui_x11_get_pixel(ctx,cbg)); XFillRectangle(ctx->display,target_pixmap,ctx->gc_background,0,0,current_card_width,current_card_height);} }else{ int f_idx=card_index_c>>3; int w_idx=card_index_c&7; int gf_param=f_idx; int gw_param=w_idx; const unsigned char** gif_set=NULL; int max_w_idx=0; if(ctx->card_style>=2){gif_set=(const unsigned char**)de_gif;max_w_idx=7;}else{gif_set=(const unsigned char**)fr_gif;max_w_idx=4;} Bool drawn=0; if(gw_param>=0&&gif_set&&gf_param<4&&gw_param<=max_w_idx&& gif_set[gf_param]&&gif_set[gf_param][gw_param]){ ui_x11_drawimg_on_pixmap(ctx,target_pixmap,card_index_c,gf_param,gw_param,x_offset,y_offset,is_large_desk); drawn=1; } if(!drawn){UI_Color fb={220,220,(unsigned char)(card_index_c*5+100),255}; XSetForeground(ctx->display,ctx->gc_background,ui_x11_get_pixel(ctx,fb)); XFillRectangle(ctx->display,target_pixmap,ctx->gc_background,0,0,current_card_width,current_card_height);}} XSetForeground(ctx->display,ctx->gc,ctx->x_black_pixel); int frm_idx=is_large_desk?1:0; for(int i=(is_large_desk?8:5);i<(is_large_desk?eff_ww-6:eff_ww-3);i++){XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+i,y_offset);XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+i,y_offset+eff_hh);} for(int j=(is_large_desk?8:5);j<(is_large_desk?eff_hh-6:eff_hh-3);j++){XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset,y_offset+j);XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+eff_ww,y_offset+j);} for(int i=0;i<(is_large_desk?6:4);i++){XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+frm[frm_idx][i][0],y_offset+frm[frm_idx][i][1]); XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+eff_ww-frm[frm_idx][i][0],y_offset+eff_hh-frm[frm_idx][i][1]); XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+frm[frm_idx][i][0],y_offset+eff_hh-frm[frm_idx][i][1]); XDrawPoint(ctx->display,target_pixmap,ctx->gc,x_offset+eff_ww-frm[frm_idx][i][0],y_offset+frm[frm_idx][i][1]);} if(card_index_c>=0){ int suit=card_index_c>>3; int val=card_index_c&7; unsigned long sym_fg_col=ctx->x_pixel_card_symbol_black; if(ctx->card_style<2){if(suit==0||suit==2)sym_fg_col=ctx->x_pixel_card_symbol_red;}else{if(suit==0||suit==1)sym_fg_col=ctx->x_pixel_card_symbol_red;} XSetForeground(ctx->display,ctx->gc,sym_fg_col); XSetBackground(ctx->display,ctx->gc,ctx->x_white_pixel); char val_s[3]; const char* vs[]={"7","8","9","B","D","K","10","A"}; snprintf(val_s,3,"%s",vs[val]); XDrawString(ctx->display,target_pixmap,ctx->gc,x_offset+5,y_offset+15,val_s,strlen(val_s)); } XSetForeground(ctx->display,ctx->gc,ctx->x_pixel_foreground); XSetBackground(ctx->display,ctx->gc,ctx->x_pixel_background);}
void ui_cleanup(UI_Context* ctx) { if (!ctx) return; ui_hide_thinking_dialog(ctx); if(ctx->thinking_gc != None) XFreeGC(ctx->display, ctx->thinking_gc); for (int i = 0; i < 33; ++i) { if (ctx->card_pixmaps[i] != None) XFreePixmap(ctx->display, ctx->card_pixmaps[i]); } if (ctx->symbols_pixmap != None) XFreePixmap(ctx->display, ctx->symbols_pixmap); if (ctx->large_symbols_pixmap != None && ctx->large_symbols_pixmap != ctx->symbols_pixmap) XFreePixmap(ctx->display, ctx->large_symbols_pixmap); if (ctx->default_font_struct) XFreeFont(ctx->display, ctx->default_font_struct); if (ctx->gc) XFreeGC(ctx->display, ctx->gc); if (ctx->gc_xor) XFreeGC(ctx->display, ctx->gc_xor); if (ctx->gc_background) XFreeGC(ctx->display, ctx->gc_background); if (ctx->back_buffer) XFreePixmap(ctx->display, ctx->back_buffer); if (ctx->arrow_cursor) XFreeCursor(ctx->display, ctx->arrow_cursor); if (ctx->hand_cursor) XFreeCursor(ctx->display, ctx->hand_cursor); if (ctx->wait_cursor) XFreeCursor(ctx->display, ctx->wait_cursor); if (ctx->display) XCloseDisplay(ctx->display); free(ctx); }
void ui_show_thinking_dialog(UI_Context* ctx, const char* message) {
    if (!ctx) return;
    ui_hide_thinking_dialog(ctx); // Close if already open
    strncpy(ctx->thinking_message_buffer, message, sizeof(ctx->thinking_message_buffer) - 1);
    ctx->thinking_message_buffer[sizeof(ctx->thinking_message_buffer) - 1] = '\0';
    int text_width = 10; int text_height = 10;
    if (ctx->default_font_struct) {
        UI_Font temp_font_wrapper; temp_font_wrapper.font_struct = ctx->default_font_struct; temp_font_wrapper.display = ctx->display;
        ui_get_text_size(&temp_font_wrapper, ctx->thinking_message_buffer, &text_width, &text_height);
    }
    int dialog_width = text_width + 40; // Add padding
    int dialog_height = text_height + 20;
    int dialog_x = (ctx->width - dialog_width) / 2;
    int dialog_y = (ctx->height - dialog_height) / 3;
    XSetWindowAttributes swa; swa.override_redirect = True;
    swa.background_pixel = ctx->x_pixel_background; // Use theme background
    swa.border_pixel = ctx->x_pixel_foreground;   // Use theme foreground
    swa.event_mask = ExposureMask;
    ctx->thinking_dialog_window = XCreateWindow(ctx->display, ctx->root_window, dialog_x, dialog_y, dialog_width, dialog_height, 1, DefaultDepth(ctx->display, ctx->screen), InputOutput, ctx->visual, CWOverrideRedirect | CWBackPixel | CWBorderPixel | CWEventMask, &swa);
    XMapRaised(ctx->display, ctx->thinking_dialog_window); // Map and raise
    XFlush(ctx->display);
    // A robust solution would wait for Expose and draw there.
    // For this subtask, we'll try a direct draw, but it's not guaranteed to show immediately or correctly without an event loop.
    // The expose event in the main loop should eventually draw it if it's not handled here.
}
void ui_hide_thinking_dialog(UI_Context* ctx) {
    if (!ctx || ctx->thinking_dialog_window == None) return;
    XDestroyWindow(ctx->display, ctx->thinking_dialog_window);
    ctx->thinking_dialog_window = None;
    XFlush(ctx->display);
}
void ui_show_game_result_dialog(UI_Context* ctx /*, UI_GameResultData* result_data */) { fprintf(stderr, "ui_x11: ui_show_game_result_dialog STUBBED.\n"); }
// (The rest of the file: ui_clear_screen, ui_present_screen, other stubs, etc. are assumed to be here correctly)
void ui_clear_screen(UI_Context* ctx, UI_Color color) { if (!ctx) return; XSetForeground(ctx->display, ctx->gc_background, ui_x11_get_pixel(ctx, color));  XFillRectangle(ctx->display, ctx->back_buffer, ctx->gc_background, 0, 0, ctx->width, ctx->height); }
void ui_present_screen(UI_Context* ctx) { if (!ctx) return; XCopyArea(ctx->display, ctx->back_buffer, ctx->main_window, ctx->gc, 0, 0, ctx->width, ctx->height, 0, 0); XFlush(ctx->display); }
UI_Texture* ui_load_texture(UI_Context* ctx, const char* file_path) { fprintf(stderr, "ui_x11: ui_load_texture for '%s' STUBBED.\n", file_path); return NULL;  }
void ui_free_texture(UI_Texture* texture) { if (texture && texture->pixmap && texture->display) { XFreePixmap(texture->display, texture->pixmap); free(texture); } }
void ui_draw_texture(UI_Context* ctx, UI_Texture* texture, const UI_Rect* src_rect, const UI_Rect* dest_rect) { if (!ctx || !texture || !texture->pixmap || !dest_rect) return; int sx = src_rect ? src_rect->x : 0; int sy = src_rect ? src_rect->y : 0; int sw = src_rect ? src_rect->w : texture->width; int sh = src_rect ? src_rect->h : texture->height; XCopyArea(ctx->display, texture->pixmap, ctx->back_buffer, ctx->gc, sx, sy, sw, sh, dest_rect->x, dest_rect->y); }
UI_Font* ui_load_font(UI_Context* ctx, const char* font_path_or_name, int point_size) { if (!ctx || !ctx->display) { fprintf(stderr, "ui_x11: UI_Context or Display not available for font loading (ui_load_font).\n"); return NULL; } XFontStruct* xfs = XLoadQueryFont(ctx->display, font_path_or_name); if (!xfs) { fprintf(stderr, "ui_x11: Failed to load font: %s\n", font_path_or_name); return NULL; } UI_Font* font = (UI_Font*)malloc(sizeof(UI_Font)); if (!font) { XFreeFont(ctx->display, xfs); return NULL; } font->font_struct = xfs; font->display = ctx->display;  return font; }
void ui_free_font(UI_Context* ctx, UI_Font* font) { if (!ctx || !font || !font->font_struct || !font->display) return; XFreeFont(font->display, font->font_struct); free(font); }
UI_Texture* ui_render_text_to_texture(UI_Context* ctx, UI_Font* font, const char* text, UI_Color color) { if (!ctx || !font || !font->font_struct || !text) return NULL; XFontStruct* fs = font->font_struct; int text_dir, text_ascent, text_descent; XCharStruct overall; XTextExtents(fs, text, strlen(text), &text_dir, &text_ascent, &text_descent, &overall); int text_width = overall.width; int text_height = overall.ascent + overall.descent; if (text_width <= 0 || text_height <= 0) return NULL; Pixmap pixmap = XCreatePixmap(ctx->display, ctx->main_window, text_width, text_height, DefaultDepth(ctx->display, ctx->screen)); if (!pixmap) return NULL; XGCValues gcv; gcv.font = fs->fid; unsigned long text_pixel = ui_x11_get_pixel(ctx, color); gcv.background = ctx->x_pixel_background;  gcv.foreground = text_pixel; GC text_gc = XCreateGC(ctx->display, pixmap, GCForeground | GCBackground | GCFont, &gcv); XFillRectangle(ctx->display, pixmap, text_gc, 0, 0, text_width, text_height);  XDrawString(ctx->display, pixmap, text_gc, 0, overall.ascent, text, strlen(text)); XFreeGC(ctx->display, text_gc); UI_Texture* ui_tex = (UI_Texture*)malloc(sizeof(UI_Texture)); if (!ui_tex) { XFreePixmap(ctx->display, pixmap); return NULL; } ui_tex->pixmap = pixmap; ui_tex->display = ctx->display; ui_tex->width = text_width; ui_tex->height = text_height; ui_tex->depth = DefaultDepth(ctx->display, ctx->screen); return ui_tex; }
void ui_get_text_size(UI_Font* font, const char* text, int* width, int* height) { if (!font || !font->font_struct || !text) { if (width) *width = 0; if (height) *height = 0; return; } int text_dir, text_ascent, text_descent; XCharStruct overall; XTextExtents(font->font_struct, text, strlen(text), &text_dir, &text_ascent, &text_descent, &overall); if (width) *width = overall.width; if (height) *height = overall.ascent + overall.descent; }
void ui_fill_rect(UI_Context* ctx, const UI_Rect* rect, UI_Color color) { if (!ctx || !rect) return; XSetForeground(ctx->display, ctx->gc, ui_x11_get_pixel(ctx, color)); XFillRectangle(ctx->display, ctx->back_buffer, ctx->gc, rect->x, rect->y, rect->w, rect->h); }
void ui_draw_rect(UI_Context* ctx, const UI_Rect* rect, UI_Color color) { if (!ctx || !rect) return; XSetForeground(ctx->display, ctx->gc, ui_x11_get_pixel(ctx, color)); XDrawRectangle(ctx->display, ctx->back_buffer, ctx->gc, rect->x, rect->y, rect->w > 0 ? rect->w -1 : 0, rect->h > 0 ? rect->h -1 : 0); }
void ui_draw_line(UI_Context* ctx, int x1, int y1, int x2, int y2, UI_Color color) { if (!ctx) return; XSetForeground(ctx->display, ctx->gc, ui_x11_get_pixel(ctx, color)); XDrawLine(ctx->display, ctx->back_buffer, ctx->gc, x1, y1, x2, y2); }
int ui_poll_event(UI_Context* ctx, UI_Event* ui_event) { if (!ctx || !ui_event) return 0; if (ctx->is_dialog_active && ctx->thinking_dialog_window == None) return 0; XEvent xev; if (XPending(ctx->display) > 0) { XNextEvent(ctx->display, &xev); if (ctx->thinking_dialog_window != None && xev.xany.window == ctx->thinking_dialog_window && xev.type == Expose) { XClearWindow(ctx->display, ctx->thinking_dialog_window); if (ctx->thinking_gc != None && ctx->default_font_struct != NULL) { XDrawString(ctx->display, ctx->thinking_dialog_window, ctx->thinking_gc, 10, 5 + ctx->default_font_struct->ascent, ctx->thinking_message_buffer, strlen(ctx->thinking_message_buffer));} XFlush(ctx->display); return 0; /* Consume expose for thinking dialog */ } if (ctx->is_dialog_active && ctx->thinking_dialog_window == None) return 0; ui_event->type = UI_EVENT_NONE; switch (xev.type) { case Expose: if (xev.xexpose.count == 0) ui_event->type = UI_EVENT_WINDOW_EXPOSED; break; case ConfigureNotify: if (xev.xconfigure.width != ctx->width || xev.xconfigure.height != ctx->height) { ctx->width = xev.xconfigure.width; ctx->height = xev.xconfigure.height; ui_event->type = UI_EVENT_WINDOW_RESIZED; ui_event->data.window_resize.w = ctx->width; ui_event->data.window_resize.h = ctx->height; if(ctx->back_buffer) XFreePixmap(ctx->display, ctx->back_buffer); ctx->back_buffer = XCreatePixmap(ctx->display, ctx->main_window, ctx->width, ctx->height, DefaultDepth(ctx->display, ctx->screen)); XSetForeground(ctx->display, ctx->gc_background, ctx->x_pixel_background); XFillRectangle(ctx->display, ctx->back_buffer, ctx->gc_background, 0,0, ctx->width, ctx->height); } break; case KeyPress: { ui_event->type = UI_EVENT_KEY_DOWN; KeySym ks = XLookupKeysym(&xev.xkey, 0); ui_event->data.key.sym = x11_keysym_to_ui_key(ks); int len = XLookupString(&xev.xkey, ui_event->data.key.text, sizeof(ui_event->data.key.text) - 1, NULL, NULL); ui_event->data.key.text[len] = '\0'; ui_event->data.key.mod = xev.xkey.state; } break; case KeyRelease: { ui_event->type = UI_EVENT_KEY_UP; KeySym ks = XLookupKeysym(&xev.xkey, 0); ui_event->data.key.sym = x11_keysym_to_ui_key(ks); ui_event->data.key.mod = xev.xkey.state; ui_event->data.key.text[0] = '\0'; } break; case ButtonPress: ui_event->type = UI_EVENT_MOUSE_BUTTON_DOWN; ui_event->data.mouse_button.x = xev.xbutton.x; ui_event->data.mouse_button.y = xev.xbutton.y; if (xev.xbutton.button == Button1) ui_event->data.mouse_button.button = 1; else if (xev.xbutton.button == Button2) ui_event->data.mouse_button.button = 2; else if (xev.xbutton.button == Button3) ui_event->data.mouse_button.button = 3; else ui_event->data.mouse_button.button = xev.xbutton.button;  ui_event->data.mouse_button.clicks = 1;  break; case ButtonRelease:  ui_event->type = UI_EVENT_MOUSE_BUTTON_UP; ui_event->data.mouse_button.x = xev.xbutton.x; ui_event->data.mouse_button.y = xev.xbutton.y; if (xev.xbutton.button == Button1) ui_event->data.mouse_button.button = 1; else if (xev.xbutton.button == Button2) ui_event->data.mouse_button.button = 2; else if (xev.xbutton.button == Button3) ui_event->data.mouse_button.button = 3; else ui_event->data.mouse_button.button = xev.xbutton.button; ui_event->data.mouse_button.clicks = 0; break; case MotionNotify: ui_event->type = UI_EVENT_MOUSE_MOTION; ui_event->data.mouse_motion.x = xev.xmotion.x; ui_event->data.mouse_motion.y = xev.xmotion.y; ui_event->data.mouse_motion.xrel = 0;  ui_event->data.mouse_motion.yrel = 0;  ui_event->data.mouse_motion.state = xev.xmotion.state; break; case ClientMessage: { Atom wm_protocols = XInternAtom(ctx->display, "WM_PROTOCOLS", False); Atom wm_delete_window = XInternAtom(ctx->display, "WM_DELETE_WINDOW", False); if (xev.xclient.message_type == wm_protocols && (Atom)xev.xclient.data.l[0] == wm_delete_window) { ui_event->type = UI_EVENT_QUIT; } } break; default: break; } if (ui_event->type != UI_EVENT_NONE) return 1; } return 0; }
void ui_set_window_title(UI_Context* ctx, const char* title_str) { if (!ctx || !title_str) return; XStoreName(ctx->display, ctx->main_window, title_str); XFlush(ctx->display); }
void ui_get_window_size(UI_Context* ctx, int* width, int* height) { if (!ctx) { if (width) *width = 0; if (height) *height = 0; return; } if (width) *width = ctx->width; if (height) *height = ctx->height; }
void ui_set_cursor(UI_Context* ctx, UI_CursorType cursor_type) { if (!ctx) return; Cursor x_cursor_to_set = ctx->arrow_cursor;  switch(cursor_type) { case UI_CURSOR_ARROW: x_cursor_to_set = ctx->arrow_cursor; break; case UI_CURSOR_HAND:  x_cursor_to_set = ctx->hand_cursor; break; case UI_CURSOR_WAIT:  x_cursor_to_set = ctx->wait_cursor; break; default: break; } XDefineCursor(ctx->display, ctx->main_window, x_cursor_to_set); XFlush(ctx->display); }
void ui_draw_card_back(UI_Context* ctx, const UI_Rect* dest_rect) { if (!ctx || !dest_rect || ctx->card_pixmaps[0] == None) return; int sw = ctx->use_large_cards ? ctx->card_width_large : ctx->card_width_small; int sh = ctx->use_large_cards ? ctx->card_height_large : ctx->card_height_small; XCopyArea(ctx->display, ctx->card_pixmaps[0], ctx->back_buffer, ctx->gc, 0, 0, sw, sh, dest_rect->x, dest_rect->y); }
void ui_draw_card_face(UI_Context* ctx, int card_index, const UI_Rect* dest_rect) { if (!ctx || !dest_rect || card_index < 0 || card_index > 31) return; Pixmap src = ctx->card_pixmaps[card_index + 1]; if (src == None) { fprintf(stderr, "ui_x11: Card face pixmap for index %d is None.\n", card_index); return; } int sw = ctx->use_large_cards ? ctx->card_width_large : ctx->card_width_small; int sh = ctx->use_large_cards ? ctx->card_height_large : ctx->card_height_small; XCopyArea(ctx->display, src, ctx->back_buffer, ctx->gc, 0, 0, sw, sh, dest_rect->x, dest_rect->y); }
void ui_display_text_at(UI_Context* ctx, const char* text, UI_Font* font_ui, UI_Color color, int x, int y, int centered) { if (!ctx || !text || !font_ui || !font_ui->font_struct) return; XFontStruct* xfs = font_ui->font_struct; GC gc = ctx->gc; XSetForeground(ctx->display, gc, ui_x11_get_pixel(ctx, color)); XSetFont(ctx->display, gc, xfs->fid);  int tx = x; int ty = y + xfs->ascent;  if (centered) { int td, ta, ts; XCharStruct ov; XTextExtents(xfs, text, strlen(text), &td, &ta, &ts, &ov); tx = x - ov.width / 2; } XDrawString(ctx->display, ctx->back_buffer, gc, tx, ty, text, strlen(text)); }
